// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// -- //
// ms //
// -- //

#define ms_wrap_target 23
#define ms_wrap 26
#define ms_pio_version 1

static const uint16_t ms_program_instructions[] = {
    0xe005, //  0: set    pins, 5                    
    0x1a49, //  1: jmp    x--, 9                 [26]
    0xe000, //  2: set    pins, 0                    
    0xa02b, //  3: mov    x, !null                   
    0x7f40, //  4: out    y, 32                  [31]
    0xdf00, //  5: irq    nowait 0               [31]
    0xe007, //  6: set    pins, 7                    
    0x00c0, //  7: jmp    pin, 0                     
    0xfb06, //  8: set    pins, 6                [27]
    0xe004, //  9: set    pins, 4                    
    0x0086, // 10: jmp    y--, 6                     
    0xe000, // 11: set    pins, 0                    
    0x4020, // 12: in     x, 32                      
    0xe001, // 13: set    pins, 1                    
    0x004f, // 14: jmp    x--, 15                    
    0x00ce, // 15: jmp    pin, 14                    
    0x4020, // 16: in     x, 32                      
    0xe002, // 17: set    pins, 2                    
    0x00d4, // 18: jmp    pin, 20                    
    0x0052, // 19: jmp    x--, 18                    
    0xe000, // 20: set    pins, 0                    
    0x5f20, // 21: in     x, 32                  [31]
    0xdf00, // 22: irq    nowait 0               [31]
            //     .wrap_target
    0xe001, // 23: set    pins, 1                    
    0x00d8, // 24: jmp    pin, 24                    
    0xe102, // 25: set    pins, 2                [1] 
    0x00e2, // 26: jmp    !osre, 2                   
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program ms_program = {
    .instructions = ms_program_instructions,
    .length = 27,
    .origin = -1,
    .pio_version = 1,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x0
#endif
};

static inline pio_sm_config ms_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + ms_wrap_target, offset + ms_wrap);
    return c;
}

// Helper function (for use in C program) to initialize this PIO program
void ms_program_init(PIO pio, uint sm, uint offset, uint pin, uint input, float div, uint pin_MEAS) {
    // Sets up state machine and wrap target. This function is automatically
    pio_sm_config c = ms_program_get_default_config(offset);
    // sm_config_set_sideset_pins(&c, pin_MEAS); //side set
    // Allow PIO to control GPIO pin (as output)
    pio_gpio_init(pio, pin);
    pio_gpio_init(pio, pin+1);
    pio_gpio_init(pio, pin_MEAS);      
    // set the pin for jump if pin high instruction
    sm_config_set_jmp_pin(&c, input); 
    // Connect pin to SET pin (control with 'set' instruction)
    sm_config_set_set_pins(&c, pin, 3);
    // Set the pin direction to output (in PIO)
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 3, true);
    // Set auto push to ISR
    sm_config_set_in_shift(&c, false, true, 32);
    sm_config_set_out_shift(&c, false, true, 32);
    // Set the clock divider for the state machine
    sm_config_set_clkdiv(&c, div);
    // Load configuration and jump to start of the program
    pio_sm_init(pio, sm, offset, &c);
}

#endif

// ------- //
// residue //
// ------- //

#define residue_wrap_target 0
#define residue_wrap 4
#define residue_pio_version 1

static const uint16_t residue_program_instructions[] = {
            //     .wrap_target
    0x37c0, //  0: wait   1 irq, 0        side 2 [7] 
    0xe72e, //  1: set    x, 14           side 0 [7] 
    0xa942, //  2: nop                    side 1 [1] 
    0x4001, //  3: in     pins, 1         side 0     
    0x0042, //  4: jmp    x--, 2          side 0     
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program residue_program = {
    .instructions = residue_program_instructions,
    .length = 5,
    .origin = -1,
    .pio_version = 1,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x0
#endif
};

static inline pio_sm_config residue_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + residue_wrap_target, offset + residue_wrap);
    sm_config_set_sideset(&c, 2, false, false);
    return c;
}

// Helper function (for use in C program) to initialize this PIO program
void residue_program_init(PIO pio, uint sm, uint offset, uint pin, float div) {
    pio_sm_config c = residue_program_get_default_config(offset);
    pio_gpio_init(pio, pin);
    // pio_gpio_init(pio, pin + 1);
    pio_gpio_init(pio, pin + 2);
    pio_gpio_init(pio, pin + 3);
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);
    // pio_sm_set_consecutive_pindirs(pio, sm, pin + 1, 1,true);  
    pio_sm_set_consecutive_pindirs(pio, sm, pin + 2, 1, true);
    pio_sm_set_consecutive_pindirs(pio, sm, pin + 3, 1, true);
    // sm_config_set_out_pins(&c, pin + 1, 1);
    sm_config_set_in_pins(&c, pin);
    sm_config_set_sideset_pins(&c, pin + 2);
    // sm_config_set_out_shift(&c, false, true, 15);
    sm_config_set_in_shift(&c, false, true, 15);
    sm_config_set_clkdiv(&c, div);
    pio_sm_init(pio, sm, offset, &c);
}

#endif

// ----------- //
// calibration //
// ----------- //

#define calibration_wrap_target 0
#define calibration_wrap 3
#define calibration_pio_version 1

static const uint16_t calibration_program_instructions[] = {
            //     .wrap_target
    0x00e4, //  0: jmp    !osre, 4                   
    0xe001, //  1: set    pins, 1                    
    0x00c2, //  2: jmp    pin, 2                     
    0xe102, //  3: set    pins, 2                [1] 
            //     .wrap
    0x6020, //  4: out    x, 32                      
    0xe001, //  5: set    pins, 1                    
    0xff00, //  6: set    pins, 0                [31]
    0xdf20, //  7: irq    wait 0                 [31]
    0xbf42, //  8: nop                           [31]
    0xe102, //  9: set    pins, 2                [1] 
    0xff00, // 10: set    pins, 0                [31]
    0xdf20, // 11: irq    wait 0                 [31]
    0xbf42, // 12: nop                           [31]
    0xe101, // 13: set    pins, 1                [1] 
    0xff00, // 14: set    pins, 0                [31]
    0xdf20, // 15: irq    wait 0                 [31]
    0xbf42, // 16: nop                           [31]
    0x0000, // 17: jmp    0                          
};

#if !PICO_NO_HARDWARE
static const struct pio_program calibration_program = {
    .instructions = calibration_program_instructions,
    .length = 18,
    .origin = -1,
    .pio_version = 1,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x0
#endif
};

static inline pio_sm_config calibration_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + calibration_wrap_target, offset + calibration_wrap);
    return c;
}

// Helper function (for use in C program) to initialize this PIO program
void calibration_program_init(PIO pio, uint sm, uint offset, uint pin, uint input, float div, uint pin_MEAS) {
    // Sets up state machine and wrap target. This function is automatically
    pio_sm_config c = calibration_program_get_default_config(offset);
    // Allow PIO to control GPIO pin (as output)
    pio_gpio_init(pio, pin);
    pio_gpio_init(pio, pin+1);
    pio_gpio_init(pio, pin_MEAS);      
    // set the pin for jump if pin high instruction
    sm_config_set_jmp_pin(&c, input); 
    // Connect pin to SET pin (control with 'set' instruction)
    sm_config_set_set_pins(&c, pin, 3);
    // Set the pin direction to output (in PIO)
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 3, true);
    // Set auto push to ISR
    sm_config_set_in_shift(&c, false, true, 32);
    sm_config_set_out_shift(&c, false, true, 32);
    // Set the clock divider for the state machine
    sm_config_set_clkdiv(&c, div);
    // Load configuration and jump to start of the program
    pio_sm_init(pio, sm, offset, &c);
}

#endif

