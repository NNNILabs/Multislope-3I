01.07.2024
Rewrote entire code to remove Dimin's DMA/PIO Interrupt routine to measure residue, which was buggy (readings had an unexplicable delay). Now, two state machines are synchronized using interrupt 0 (note, synchronization is not perfect when using different clock dividers for each state machine, even if they are integer multiples). SM0 handles runup, start and stop, while SM1 handles reading the residue ADC. 

02.07.2024
Implemented chip select for residue ADC. Different state machines in a PIO block can have different in, out, set and sideset pins. First readings had 100uVpp noise at 1PLC, which mostly came from the residue difference. Runup counts were rock solid at 2999. Optimized runup code by removing redundant instructions. Moving purely decremental loops (loop counter not intended to go to zero) to the top of the PIO code helps with program flow by allowing 'top-down' execution, eliminating the need for jump instructions. Wrote a crude implementation of Kleinstein's rundown algorithm - constant + and - pulses whose length depends on the integrator state (determined by sampling the comparator). Bipolar rundown adds approximately 3 bits of resolution (integrator voltage spread before rundown was 8x after rundown), should theoretically reduce noise by that much. The + and - loops show differrent response times because the 'jmp pin' is used differently, causes a constant offset in the - loop. 

03.07.2024
Came up with a new calibration scheme to combine residue ADC with PWM runup - do 3 runup cycles (1 is too short for effective residue reading) to measure residue difference, should be equivalent to how much integrator changes in 1 PWM cycle, residue difference is then how many residue ADC counts are in 1 PWM cycle. After reading, multiply runup counts (2 * negative switch cycles - total PWM cycles) by calibrated residue difference, then add the residue difference of that reading.
Did three-phase auto zero on the calibrated reading, noise is generally within 10μVpp with some outliers. Mark elaborated calibration scheme with 2 runup and 3 runup cycles to compensate for the difference between the two slopes. 2 runup cycles delivers the difference between the two slopes (in my case, around 8mV), while 3 runup cycles delivers the residue resolution in terms of one runup cycle.

04.07.2024
Jaromir elaborated on the residue calibration algorithm. One runup, residue difference = R1; One runup, one rundown, residue difference = R2; One runup, one down, one up, residue difference = R3. One down cycle = R2 - R1, one up cycle = R3 - R2. After normal measurement, count number of 'up' (+) cycles, multiply by (R3-R2), count number of 'down' (-) cycles, multiply by (R2 - R1), (signed) add, add residue difference.
Wrote a separate calibration PIO program that involved a lot of hacks. irq wait didn't behave properly at all, turns out the problem was very complicated since the SPI code involved in and out shifting. Fixed using delays in the C/C++ code. Finally got the 1-2-3 calibration scheme up and running.
Noise is still in the range of 100μVpp. Discovered a math mistake in yesterday's run, forgot to multiply by abs Vref. I suspect modulation frequency is too high for my circuit.
TODO: Clean up rundown code and read the rundown counts. Optimize code to save some instructions if necessary. Try to remove the offset in the - loop.
possible optimization - reduce need for delay in runup by using 'irq wait', irq 0 [20] uses a lot of delays, half the total delay could gain one sideset pin.